"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns snapped ids at cluster coords.
 *
 * ### Example (ts module)
 * ```ts
 * import { snap } from 'snap-to-grid-clustering';
 * snap([[-1, 1], [2, 3], [10, 10], [11, 11]], 5)
 * // => { '0,0': [ 0 ], '0,1': [ 1 ], '2,2': [ 2, 3 ] }
 * ```
 *
 * ### Example (es module)
 * ```js
 * import { snap } from 'snap-to-grid-clustering'
 * console.log(snap([[-1, 1], [2, 3], [10, 10], [11, 11]], 5))
 * // => { '0,0': [ 0 ], '0,1': [ 1 ], '2,2': [ 2, 3 ] }
 * ```
 *
 * ### Example (commonjs)
 * ```js
 * var snap = require('snap-to-grid-clustering').snap;
 * console.log(snap([[-1, 1], [2, 3], [10, 10], [11, 11]], 5))
 * // => { '0,0': [ 0 ], '0,1': [ 1 ], '2,2': [ 2, 3 ] }
 * ```
 */
function snap(coords, gridSize) {
    return coords.reduce((snappedCoordsPart, coord, coordIndex) => {
        const key = coord
            .reduce((keyPart, axle) => {
            return `${keyPart},${Math.round(+axle / gridSize)}`;
        }, '')
            .substr(1);
        return Object.assign({}, snappedCoordsPart, { [key]: snappedCoordsPart[key]
                ? [...snappedCoordsPart[key], coordIndex]
                : [coordIndex] });
    }, {});
}
exports.snap = snap;
/**
 * Returns snapped ids as list.
 *
 * ### Example (ts module)
 * ```ts
 * import { snapList } from 'snap-to-grid-clustering';
 * snapList([[-1, 1], [2, 3], [10, 10], [11, 11]], 5)
 * // => [[0], [1], [2, 3]]
 * ```
 *
 * ### Example (es module)
 * ```js
 * import { snapList } from 'snap-to-grid-clustering'
 * console.log(snapList([[-1, 1], [2, 3], [10, 10], [11, 11]], 5))
 * // => [[0], [1], [2, 3]]
 * ```
 *
 * ### Example (commonjs)
 * ```js
 * var snapList = require('snap-to-grid-clustering').snapList;
 * console.log(snapList([[-1, 1], [2, 3], [10, 10], [11, 11]], 5))
 * // => [[0], [1], [2, 3]]
 * ```
 */
function snapList(coords, gridSize) {
    return Object.values(snap(coords, gridSize));
}
exports.snapList = snapList;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RnYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3RnYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCRztBQUNILFNBQWdCLElBQUksQ0FBQyxNQUFjLEVBQUUsUUFBZ0I7SUFDbkQsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUNsQixDQUFDLGlCQUFnQyxFQUFFLEtBQVksRUFBRSxVQUFrQixFQUFFLEVBQUU7UUFDckUsTUFBTSxHQUFHLEdBQVcsS0FBSzthQUN0QixNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDeEIsT0FBTyxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDdEQsQ0FBQyxFQUFFLEVBQUUsQ0FBQzthQUNMLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLHlCQUNLLGlCQUFpQixJQUNwQixDQUFDLEdBQUcsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLEdBQUcsQ0FBQztnQkFDM0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsRUFBRSxVQUFVLENBQUM7Z0JBQ3pDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUNoQjtJQUNKLENBQUMsRUFDRCxFQUFFLENBQ0gsQ0FBQztBQUNKLENBQUM7QUFqQkQsb0JBaUJDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJHO0FBQ0gsU0FBZ0IsUUFBUSxDQUFDLE1BQWMsRUFBRSxRQUFnQjtJQUN2RCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFGRCw0QkFFQyJ9